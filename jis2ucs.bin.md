# jis2ucs.binについて
`jis2ucs.bin`はJIS X 0213のUnicodeに対する対応テーブルのファイルです。
[aozorahack](https://github.com/aozorahack)様の[`jis2ucs.yml`](https://github.com/aozorahack/aozora2html/blob/master/yml/jis2ucs.yml)をバイナリ形式にしたものです。
ファイル構造は、各2バイト、2\*94\*94の3次元配列です。
ただし後述の通り、途中を省略しています。

先頭2バイトは`02 13`にしています。
これはスペースなし`0213`で検索した時、ファイル鑑定が容易になるようにです。

面句点番号をa-b-cとした場合、`(((a-1)*94+(b-1))*94+c)*2`バイト目に要素があります。
そのままメモリに展開しランダムアクセスが可能です。
容量節約の工夫をしているため、全展開せずにUnicodeからの逆引きはできません。

なお本文中「16進数n桁目」は左から順番に数えています。1始まりです。
例えば1バイトでの1桁目は上位4ビットを示します。
6バイトで4桁目は2バイト目の下位4ビットを示します。

以前には同名の別のバイナリ形式を用いていました([旧ドキュメント](../JIS2UCS3/jis2ucs.bin%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6.md))。

## 実体参照表現
`jis2ucs.yml`においてJIS X 0213の文字を実体参照した場合は以下の3種類で表現されます。

1. `&#x****;` (16進4桁1文字)
2. `&#x2****;` (16進5桁1文字/サロゲートペア)
3. `&#x****;&#x****;` (16進4桁2文字)

全ての要素で`&#x000*;`に該当する文字は(制御文字なので)ありません。
2.の場合16進数部分の先頭は必ず2です。
また全て16進数大文字0埋め4桁以上で表現されています。
いずれにおいても先頭が`A-E`に該当する文字はありません。

なおサロゲートペアにおいてはUTF-16表現と実体参照で使われるコードポイントは異なる点に注意してください。

## アドレス変換
本来のアドレスが`50AA`から`7D95`までの領域を省略しています。簡単な圧縮です。
これは2面16区79点から2面77区94点(2面78区01点直前)までに相当します。

実際のアドレスを参照する時は、本来のアドレスが、

* `50AA`から`7D95`までは`00 00`として扱う
* `7D96`以上では`7D96-50AA=2CEC`分減らす

処理を行ってください。

ファイル構造とプログラムの簡素化の為、この変換情報はファイル自体に含まれていません。

```csharp
        static int VirtualPosToRealPos(int pos)
        {
            const int BlankStart = 0x50AA;//kurema:2面16区79点
            const int BlankEnd = 0x7D96;//kurema:2面78区01点

            switch (pos)
            {
                case >= BlankStart and < BlankEnd:
                    return -1;
                case >= BlankStart:
                    return pos - (BlankEnd - BlankStart);
                default:
                    return pos;
            }
        }
```

## ポインタ表現
該当する要素の1バイト目が`B0-EF`までの範囲であれば、ポインタで表現されています。

ポインタはリトルエンディアンの2バイトです。
ポインタは`B0 00`がファイル先頭を示し、2バイト単位です。
バイト単位で参照する場合は`B0 00`分減らし2倍してください。

また結果はアドレス変換の本来のアドレスを示しています。
さらに実際のアドレスに変換してください。

```csharp
VirtualPosToRealPos((((dic[pos] - 0xB0) << 8) + dic[pos + 1]) * 2);`
```

## 各要素の記述
各要素は2バイト毎にリトルエンディアンで表現されます。
また上の3種類に対して以下のように記述されます。

### 空白要素
該当する要素が存在しない場合は以下の三種類のいずれかになります。

1. ファイル領域外
2. 16進数表現1桁目が`A`
3. `00 00`

2.の場合、この領域は別の文字を表現するのに用いられています。

### 1. `&#x****;` (16進4桁1文字)
16進4桁がそのままビッグエンディアンで表現されています。
`&#xABCD;`の場合は`AB CD`になります。

実際には1桁目が`A-E`の範囲になる要素は存在しないため、別の目的で使われています。

### 2. `&#x2****;` (16進5桁1文字/サロゲートペア)
ファイル内のポインタで表現されています。

ポインタの参照先では4バイトを用いて表現されます。
これを16進8文字で表現した場合の対応は以下の通りです。

| バイナリ16進表現 | 値 | 実体参照16進数表現 |
| -- | -- | -- |
| 1桁目 | A | |
| 2桁目 | 2 | 1桁目 |
| 3～4桁目 | 00-FF | 2～3桁目 |
| 5～6桁目 | A2 |  |
| 7～8桁目 | 0-F | 4～5桁目 |

`&#x2BCDE;`の場合、参照先は`A2 BC A2 DE`になります。

6桁目が2なのは、1桁余るので多少目印になる文字にしただけです。

### 3. `&#x****;&#x****;` (16進4桁2文字)
ファイル内のポインタで表現されています。

ポインタの参照先では6バイトを用いて表現されます。
これを16進8文字で表現した場合の対応は以下の通りです。

| バイナリ16進表現 | 値 | 実体参照16進数表現 |
| -- | -- | -- |
| 1桁目 | A0 |  |
| 3～4桁目 | 00-FF | 1文字目1～2桁目 |
| 5桁目 | A | |
| 6～7桁目 | 0-F | 1文字目3～4桁目 |
| 8桁目 | 0-F | 2文字目1桁目 |
| 9桁目 | A | |
| 10～12桁目 | 0-F | 2文字目2～4桁目 |

`&#x1234;&#xBCDE;`の場合、`A0 12 A3 4B AC DE`になります。 

## サイズ比較
ファイルサイズは23,844バイトです。
これは従来のバイナリ形式をgzip圧縮した結果より僅かに大きいサイズです。
さらにgzip圧縮した結果は23,120バイトと僅かに圧縮可能で、従来のgz圧縮より僅かに大きくなりました。
圧縮可能分の多くは1バイト目が`00`のASCII文字だと考えられます。`30`も割と多いです。

| 種類 | サイズ (バイト) | 備考 |
| -- | -- | -- |
| jis2ucs.yml | 236,400 | 元々のファイル |
| (旧)jis2ucs.bin | 70,692 | バイナリ形式 |
| (旧)jis2ucs.gz | 22,278 | 圧縮後 |
| jis2ucs.bin | 23,830 | バイナリ形式 |
| jis2ucs.bin.gz | 22,915 | 圧縮後/実際は使用せず |

参考 (C#で該当コードを記述した場合。各Debugビルド)

| 種類 | サイズ (バイト) | 備考 |
| -- | -- | -- |
| string入力実体参照出力 | 941,056 | 単純なstringのswitch文。実体参照を文字列で表現。 |
| int入力実体参照出力 | 391,680 | 面句点番号のswitch文。実体参照を文字列で表現。 |
| int入力Unicode出力 | 233,984 | 面句点番号のswitch文。該当する文字で表現。 |

## 従来形式との比較
従来のバイナリ形式と比較したメリットは以下の通りです。

* メモリ展開時の容量が半分以下に縮小した。そのままランダムアクセス可能。
* gzip圧縮無しでも同等のファイルサイズになり、圧縮が不要になった。
* ビッグエンディアンなので16進4桁1文字についてはバイナリエディタ上での確認が簡単になった。

デメリットは以下の通りです。

* 単純な走査によるコードポイントからの逆引き検索が不可能になった。
* 構造が複雑でプログラミングが難しくなった。
* UTF-16でもUTF-8でもないので、テキストエディタで文字が確認できなくなった。
* 16進4桁1文字以外の場合はバイナリエディタ上での確認が困難になった。
* 境界でバグが発生する可能性が高まった。
  * ファイルは全文字テスト済み。ただし空白要素は全てテストしていない。
  * aozora2sharpでは境界条件のテストを追加しました。
* gzip圧縮後と比べファイルサイズが微増した。
* 処理が複雑になりポインタ参照も加わった結果、実行時間が増える可能性がある。

デメリットが多く見えますが、メモリ展開時のサイズ削減は様々なキャッシュにも乗りやすくなり、gzip展開が不要になりどちらかと言えばパフォーマンス向上寄りだと考えています。
ただし、実際のストレージ消費量・メモリ消費量・パフォーマンスの差は無視できる程度でしょう。
単純にバイナリの空白を埋めたくなったから実装しただけのものです。
