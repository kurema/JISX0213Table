# jis2ucs.old.binについて
`jis2ucs.old.bin`は[`jis2ucs.yml`](https://github.com/aozorahack/aozora2html/blob/master/yml/jis2ucs.yml)をバイナリ形式にしたものです。
ファイル構造は、各4バイト・2\*94\*94の3次元配列です。
先頭4バイトは`FE FF 00 00`にしています。
これはUTF-8のBOMに相当するものです。

つまり面句点番号をa-b-cとした場合、`(((a-1)*94+(b-1))*94+c)*4`バイト目に要素があります。
仕様上、多くの領域は空白です。
そのままメモリに展開しランダムアクセスが可能です。

## 実体参照表現
`jis2ucs.yml`においてJIS X 0213の文字を実体参照した場合は以下の3種類で表現されます。

1. `&#x****;` (16進4桁1文字)
2. `&#x2****;` (16進5桁1文字/サロゲートペア)
3. `&#x****;&#x****;` (16進4桁2文字)

全ての要素で`&#x000*;`に該当する文字は(制御文字なので)ありません。
2.の場合16進数部分の先頭は必ず2です。
また全て16進数大文字0埋め4桁以上で表現されています。

## 各要素の記述
各要素は2バイト毎にリトルエンディアンで表現されます。
また上の3種類に対して以下のように記述されます。

### 1. `&#x****;` (16進4桁1文字)
1. 前半2バイトは`00 00`固定です。
2. 後半2バイトはリトルエンディアンで16進数1～4桁目が表現されます。

つまり`&#xABCD;`の場合、`00 00 CD AB`と表現されます。

UTF-16と同じ表現でBOMもあるので、バイナリエディタで適切に表示されます。

### 2. `&#x2****;` (16進5桁1文字/サロゲートペア)
1. 前半2バイトは`02 00`固定です。
2. 後半2バイトはリトルエンディアンで16進数2～5桁目が表現されます。

つまり`&#x2ABCD;`の場合、`02 00 CD AB`と表現されます。

UTF-16と異なる表現なので、バイナリエディタでは適切に表現されません。
このプログラムでは`jis2ucs.yml`と同じ表現を確実に復元することを目的としているので、単なる16進数表現として扱っています。
また仕様上は先頭は1～Fのいずれでも対応可能です。

### 3. `&#x****;&#x****;` (16進4桁2文字)
1. 前半2バイトはリトルエンディアンで1文字目16進数1～4桁目が表現されます。
2. 後半2バイトはリトルエンディアンで2文字目16進数1～4桁目が表現されます。

つまり`&#x1234;&#xABCD;`の場合、`34 12 CD AB`と表現されます。

UTF-16と同じ表現でBOMもあるので、バイナリエディタで適切に表示されます。
半濁点付きのひらがな・カタカナが該当するようです。

### 空白要素
該当する要素が存在しない番号は`00 00 00 00`で表現されます。

## jis2ucs.gz
~~空白が多いので、gzipで圧縮を行っています。
埋め込みリソースの仕様上`jis2ucs.bin.gz`ではなく`jis2ucs.gz`のファイル名にしています。~~

ファイルサイズは22,278バイトです。

| 種類 | サイズ (バイト) | 備考 |
| -- | -- | -- |
| jis2ucs.yml | 236,400 | 元々のファイル |
| jis2ucs.bin | 70,692 | バイナリ形式 |
| jis2ucs.gz | 22,278 | 圧縮後 |

参考 (C#で該当コードを記述した場合。各Debugビルド)

| 種類 | サイズ (バイト) | 備考 |
| -- | -- | -- |
| string入力hex出力 | 941,056 | 単純なstringのswitch文。実体参照を文字列で表現。 |
| int入力hex出力 | 391,680 | 面句点番号のswitch文。実体参照を文字列で表現。 |
| int入力char出力 | 233,984 | 面句点番号のswitch文。該当する文字で表現。 |

## 改善案
いくつか改善しうる点があります。

### ビッグエンディアン
バイナリエディタで覗く場合、ビッグエンディアンの方が分かりやすいのでそうすれば良かった気がします。
ファイル作成が少し楽だったのでこうしただけで、特にリトルエンディアンにする理由があった訳ではありません。
なお参照はバイト単位で行っているので、エンディアンが異なる環境でも正常に動作します。

### 容量削減
現時点では一要素に必ず4バイト使用している、また空白は0埋めで表現されているので非効率です。
検索したところ、`jis2ucs.yml`には16進数表現1桁目がA～Eの文字は存在しないので、特殊処理に使えます。
具体的には以下のような仕様が考えられます。

* 各要素4バイトではなく2バイト使う。
* 16進数1桁目がAの場合、空白要素として扱う。
* 16進数1桁目がB～Eの場合、`B000`分減らし`0000`～`3FFF`の数値として扱い、2倍し、ファイル先頭から当該バイト離れた位置を参照する。
* 参照先は空白要素。連続した6バイトを用いる。`A000`分減らし、3桁*3で表現する。1桁余るのでサロゲートペアを4バイトで表現することも可能。

`3FFF`は16,383です。2倍で32,766です。
この場合のファイルサイズは35,348バイトなので、全域を表現できます。
確認していませんが、おそらく空白要素の数は足りると思います。
空白要素に詰め込むのではなく、全要素が終わってから表現しても構いません。

現時点ではたかだか35kbをそこまでして節約する必要を感じていないのでこうしていません。
加えてここまでしてもgzip圧縮よりわずかに大きなサイズになります。
さらにバイナリエディタで確認できなくなるという些細なデメリットもあります。

ただバイナリエディタで00がなく、がっちり埋まっているバイナリファイルはカッコいいと思います。

なお先頭4バイトを削っても構いませんが、無意味だと思います。

### 補足
気が変わって、上の改善案を実施しました。
加えて、仕様上大きな空白があったので、その部分も埋めておきました。
